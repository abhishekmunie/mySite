// Generated by CoffeeScript 1.7.1
var fs, walkDirectory,
  __slice = [].slice;

fs = require('fs');

module.exports.equire_all_in = function(path) {
  var ext, file, fn, list, required, stat, _i, _len;
  required = {};
  list = fs.readdirSync(dir);
  if (list.length === 0) {
    return void 0;
  }
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    file = list[_i];
    if (file === 'Icon\r' || /(^|\/)\./.test(file)) {
      continue;
    }
    fn = path.resolve(dir, file);
    ext = path.extname(file);
    stat = fs.statSync(fn);
    if (stat.isDirectory()) {
      required[file] = require_all_in(fn);
      required[file].isDirectory = true;
    } else if (require.extensions[ext]) {
      required[path.basename(file, ext)] = require(fn);
    }
  }
  return required;
};

module.exports.walkDirectory = walkDirectory = function(dir, error, onFile, end) {
  return fs.readdir(dir, function(err, list) {
    var file, l, _i, _len, _results;
    if (err) {
      error(err);
      return end();
    }
    l = list.length;
    if (l === 0) {
      return end();
    }
    _results = [];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      file = list[_i];
      if (file === 'Icon\r' || /(^|\/)\./.test(file) || /\.(bak|config|sql|fla|psd|ini|log|sh|inc|swp|dist|tmp|node_modules|bin)|~/.test(file)) {
        if (--l === 0) {
          end();
        }
        continue;
      }
      _results.push((function(fn) {
        return fs.lstat(fn, function(err, stat) {
          if (err) {
            error(err);
            if (--l === 0) {
              return end();
            }
          } else if (stat && stat.isDirectory()) {
            return walkDirectory(fn, error, onFile, function() {
              if (--l === 0) {
                return end();
              }
            });
          } else {
            onFile(fn);
            if (--l === 0) {
              return end();
            }
          }
        });
      })(dir + '/' + file));
    }
    return _results;
  });
};

module.exports.merge = function() {
  var key, obj, objs, target, val, _i, _len;
  target = arguments[0], objs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = objs.length; _i < _len; _i++) {
    obj = objs[_i];
    for (key in obj) {
      val = obj[key];
      target[key] = obj[key];
    }
  }
  return target;
};

module.exports.mkpath = function(dirpath, callback) {
  dirpath = path.resolve(dirpath);
  return fs.stat(dirpath, function(err, stats) {
    if (err) {
      if (err.code === 'ENOENT') {
        return mkpath(path.dirname(dirpath), function(err) {
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          } else if ((callback != null) && createdDir[dirpath] === true) {
            return process.nextTick(callback);
          } else {
            if (!createdDir[dirpath]) {
              createdDir[dirpath] = [];
              console.log("Creating Directory: " + dirpath);
              fs.mkdir(dirpath, function() {
                var cb, _i, _len, _ref, _results;
                _ref = createdDir[dirpath];
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  cb = _ref[_i];
                  _results.push(cb(arguments));
                }
                return _results;
              });
            }
            if (callback != null) {
              return createdDir[dirpath].push(callback);
            }
          }
        });
      } else {
        return typeof callback === "function" ? callback(err) : void 0;
      }
    } else if (stats.isDirectory()) {
      return typeof callback === "function" ? callback() : void 0;
    } else {
      return typeof callback === "function" ? callback(new Error(dirpath + ' exists and is not a directory')) : void 0;
    }
  });
};

//# sourceMappingURL=helper.map
